\section{Seigniorage}

In Highway, validators are rewarded for proposing and finalizing blocks. New tokens are minted at the end of each era through seigniorage, and distributed to validators according to their performance in that era. We do not have constant block rewards as in Proof of Work blockchains like Bitcoin and Ethereum---instead, a constant reward is allocated for each protocol round, and paid out to validators while looking at multiple factors, such as finality and participated weight. We immediately make the following distinction to avoid future confusion:

\begin{description}
\item[Weight:] a validator's bonded stake used in consensus.
\item[Assigned weight:] the total stake of validators that are scheduled to participate in a round.
\item[Participated weight:] the total stake of validators that actually end up participating, which requires sending messages to finalize a round before it ends.
\end{description}

In general, we will be looking at two criteria to determine the validators' eligibility to receive rewards from a participated round:

\begin{description}
\item[On-time finalization (OTF):] Validators should finalize rounds on time, by sending required messages before their respective rounds end. We set OTF to require only a small but sufficient participating weight, for a simple reason: the probability of receiving a message on time decreases as the duration required for that approaches network propagation delay, so there is a trade-off between round lengths and assigned weight. We favor faster rounds over higher short-term safety guarantees, and argue that the latter can be achieved once the rounds end.
\item[Eventual finality (EF):] Complementary to the lower safety guarantees of OTF, we want all validators to vote in a round once a long enough time passes. This is possible, because validators that are not assigned to a round can still vote for it by participating on one of its descendants. The higher the weight voting in a round, the better.
\end{description}

We emulate the evolution of finality in Proof of Work blockchains by having validators to finalize a round with a relatively low but sufficiently high guarantee in the short run, and incentivizing them to provide the highest guarantee in the long run. This mirrors how a block becomes safer in Proof of Work as more blocks pile up on it.

For a given round, complementary portions of the round reward is allocated for OTF and EF respectively. Eligibility for OTF rewards follows an all-or-nothing approach: it is burned if the round is not finalized on time. EF eligibility, on the other hand, exists on a sliding scale: the more weight votes in a round, the more of the allocated portion is rewarded. This incentivizes validators to increase the weight voting for blocks in the long run.

\subsection{Rounds and the Round Schedule}
\label{sec:schedule}

Let $V$ be the set of validators, and be $\boldsymbol{w}:V\to \mathbb{R}_{\geq 0}$ a map assigning to each validator $v\in V$ their weight (and other conventions follow from the Highway paper).

The schedule with which validators send messages are determined by the validators' rounds, which are in turn determined by their round exponents. A validator with the round exponent $n$ can and has to participate in rounds that repeat every $2^n$ ticks. When a validator wants to adjust its round exponent, they can announce a new value \emph{in any message}. But the new value comes into force \emph{once the round that they have made the announcement ends}. Eventually, the announcements yield a map $n_v: \mathbb{N}\to \mathbb{N}$ which maps each validator $v$ to the announced round exponents. Also, the above rule dictates that $n_v(i)=n_v(i-1)$ unless $i$ is a multiple of both $2^{n_v(i)}$ and $2^{n_v(i-1)}$. The \emph{schedule} then refers to the set of all $n_v$ for each $v$. See \cite{kane2019casperlabs}, section \emph{Leaders and Ticks} for more details.

We mean by \emph{round $i$ of validator $v$} the period that starts at tick $i$ in which $v$ has to participate. When we just mention \emph{round} $i$ without referring to a validator, we mean all rounds that start at $i$. Given a round $i$, the leader is scheduled to propose a block $\mathcal{L}(i)$ if the condition $i\mod 2^{n_{\mathcal{L}(i)}(i)}=0$ is satisfied. Rounds are conceptually divided into three phases:

\begin{enumerate}
\item \textbf{Proposal phase:}
  The leader $\mathcal{L}(i)$ has to send a \PROP{} (i.e. a proposal message, which may or may not contain transactions).
\item \textbf{Confirmation phase:}
  Voters $V_i\setminus \mathcal{L}(i)$ that receive the \PROP need to acknowledge it by sending a \CONF (i.e. a confirmation message, which may or may not contain transactions), i.e.~a ballot which cites the \PROP.
\item \textbf{Attestation phase:}
  Both the leader and the voters need to acknowledge the \CONF{}s by sending a \WIT{} (i.e. a witness message, which may or may not contain transactions), i.e.~a ballot which cites the \CONF{}s that they have seen.
\end{enumerate}

We denote by $V_{i}=\{v\in V \mid i \mod 2^{n_v(i)} = 0\}$ the subset of validators that is scheduled to participate in round $i$. \emph{Assigned weight} of a round $i$, defined in the previous section, is denoted by $\boldsymbol{w}(V_i)$.

If the leader does not send a \PROP, voters cannot send \CONF{}s--- because a \CONF that does not cite the same round's \PROP is deemed invalid---, but they can still send \WIT{}s, which cite and contribute to the finality of any previous messages.

Each validator is assessed according to their own round exponent. All assigned validators become eligible to receive rewards as long as the round gets finalized with messages that were sent within each validator's own round. If everything goes as planned, at the end of a round, the leader's proposal is finalized, but probably nothing else. Other messages get finalized only when they get cited by the next leader's \PROP. \emph{For that reason, we use ``finalized round'' as a synonym for ``finalized \PROP'', and nothing else, throughout this paper.} Here, we intentionally do not make a distinction between blocks and other types of messages, because Highway is agnostic of whether a message contains transactions or not. All three types of messages introduced above could be set to contain transactions, classifying them as blocks. However, the seigniorage incentive mechanism is not concerned with such a distinction. It only focuses on whether the \PROP is finalized, and if so, the weight of the committee that finalized it.

\subsection{Message Validity}
\label{sec:message-validity}

The round exponents determine the schedule for proposing and voting on blocks. Validators \emph{are not allowed} to contribute to consensus by sending messages outside their rounds\footnote{Note by Andreas: I think we should take every opportunity to limit the structure the DAG can have. The more freely the adversary can shape the message graph, the more likely it is that they'll be able to exploit some inefficiencies in e.g.~our fork choice implementation or our finality detector. Limiting to what extent your round exponent can differ from the others', and disallowing more than two ballots (plus one block, if you're the leader) per round, seems like a good way to get that ``arbitrary DAG shape'' problem under control.}. In the next paragraph, we present validity conditions for messages.

Every message $\mu$ by a validator $v$ always belongs to a unique round: $\mu$ explicitly only contains a tick $t$. So we check what the $v$'s current round exponent $n$ is by looking at the last message in $v$'s previous round. Then we find the greatest $i\leq t$ such that $i$ is divisible by $2^n$. Round $i$ of $v$ is the one this message belongs to. Then $\mu$ is valid only if $S(\mu)\in V_i$, and it satisfies either of the following conditions:

\begin{itemize}
\item
  $v$ is the round leader of $i$ AND $t = i$,
\item
  OR $\mu$ is a ballot and there are no more than 1 messages
  \emph{from} $v$ before $\mu$ with a tick greater than $i$.
\end{itemize}

A validator $v$ can be said to have \emph{fully participated in round $i$} if and only if $i \leq T(\mu) <i+2^{n_v(i)}$ holds for each of their messages $\mu$ that is required for finality in round $i$. In other words, each validator, depending on whether they are a leader or a voter, has to send the necessary \PROP, \CONF and \WIT messages required for finalization before their respective round ends. Non-participation does not have to imply not receiving any rewards though---see Section~\ref{sec:reward-allocation-eligibility}.

\subsection{In-Roundness}
\label{sec:in-roundness}

We define by \emph{in-round messages of round $i$} each \textbf{valid} message $\mu$ by $v\in V_i$ that satisfies $i \leq T(\mu)< i+2^{n_v(i)}$, and we denote it by the property $p_i$. This definition will be used below to introduce a restricted type of summit that is considered only for on-time finalization rewards.

Given a round $i$ of validator $v$, a message is \emph{out-of-round} in the context of $i$ if $T(\mu)\geq i+2^{n_v(i)}$.

Validators do not have to be assigned to a round to vote for the corresponding \PROP. Voting can also happen through out-of-round messages. A message $\mu$ \emph{votes} for for a \PROP $P$ if either of the following conditions are satisfied:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item $\mu$ is $P$ itself.
\item $\mu$ is a \PROP which is a main-descendant of $P$.
\item $\mu$ is a \CONF or \WIT, voting explicitly for $P$.
\item $\mu$ is a \CONF or \WIT, voting explicitly for a main-descendant of $P$.
\end{enumerate}

Here, in-round messages fall under (1) and (3), whereas out-of-round messages can fall under (2), (3) or (4). Only in-round messages are considered for OTF, so only assigned validators can contribute their weight for OTF. However, all valid messages are considered for EF, so all validators can contribute their weight for EF.

Also, validators are allowed to \emph{justify} messages from rounds that they are not included in---they are just not be rewarded for it.

\subsection{Round Feasibility}
\label{sec:round-feasibility}

The safety theorem dictates that a level-$k$ summit requires a quorum size of at least

\begin{equation}
q = \frac{\boldsymbol{w}(V)}{2} + \frac{t_f}{2(1-2^{-k})}
\end{equation}

in order to remain valid for a fault tolerance threshold of $t_f$. We always consider level-1 summits for OTF, so the target quorum size becomes $q=\boldsymbol{w}(V)/2+t_f$. We also target a low $t_f$, e.g.~1\% of total weight, due to the reason explained above. For the given $t_f$, the target quorum size then becomes $q_{OTF} = 0.51 \times \boldsymbol{w}(V)$.

We set $q_{OTF}$ as a protocol parameter and define

\begin{equation}
I = \{i\in \mathbb{N} \mid \boldsymbol{w}(V_i)\geq q_{OTF}\}
\end{equation}

to be the set of ticks where the assigned weight is sufficient for OTF. Such ticks are said to be \emph{feasible}, and the ticks that do not satisfy this condition are said to be \emph{infeasible}. Given a feasible tick, the corresponding the rounds that start on it are also said to be feasible. Only feasible rounds are eligible for rewards, and participating in an infeasible round does not earn any reward. In other words, a round's finality can be rewarded only if enough validators have announced to vote on it.

It is ideal to have the validators converge on the same round exponent, because then the participated weight would be maximized for each round. For that reason, reward allocated per round is a function of the total weight assigned to the corresponding tick.

\subsection{Finality Criteria}
\label{sec:finality-criteria}

\subsubsection*{On-Time Finalization}
\label{sec:on-time-finalization}

OTF is concerned with the finality that is achieved in the short run, with in-round messages. For the sake of detecting this short-term finality, we restrict ourselves to \emph{summits that are achievable only by in-round messages}.

A summit is defined as $\mathcal{S}=((C_j)_{j\in\mathbb{N}}, \sigma,p,p',q)$ where the respective properties $p$ and $p'$ are determined by the fork choice rule. We are interested in summits achievable only by valid in-round messages, so we introduce the property

\begin{equation}
  p_i = \{\mu \mid i \leq T(\mu)< i+2^{n_{S(\mu) }(i)}\;\text{and}\;\mu\text{ is valid}\}
\end{equation}

to be true for valid messages sent in round $i$. Then we extend $p'$ to obtain

\begin{equation}
  p'_{i}(\mu) = p'(\mu)\quad\text{and}\quad p_{i}(\mu)
\end{equation}

and introduce for a round $i$ the summit achievable only by in-round messages as $\mathcal{S}_i=((C_j)_{j\in\mathbb{N}}, \sigma,p,p'_{i},q_{OTF})$.

With this extended definition, we are ready to define on-time finality: A \PROP sent on $i$ is said to be \emph{finalized on time} only if the summit on it $\mathcal{S}_i$ is of level-1 once the rounds of all participants end.

\emph{Participated weight} in the context of a \PROP sent on $i$ is formally represented as $\boldsymbol{w}(C_1)$, and is restrained by assigned weight, such that $\boldsymbol{w}(C_1) \leq \boldsymbol{w}(V_i)$.

\subsubsection*{Eventual Finality}
\label{sec:eventual-finality}

EF is concerned with the finality that is achieved in the long run, and is not restricted to in-round messages. This way, the weight on a \PROP can increase up to 100\% of the total weight. Unlike OTF, which fails if a base level of weight is not observed by the end of the round, EF is not binary. It exists on a sliding scale: the higher the weight, the better.

The goal is to have all validators voting on a \PROP by the end of the era. Let $\mathcal{S}$ be the summit on a \PROP, according to all the messages sent in the era that the \PROP belongs to. If OTF is successful, then we already have $\boldsymbol{w}(C_1)\geq q_{OTF}$. We define

\begin{equation}
f_{EF} = \left(\frac{\boldsymbol{w}(C_1) - q_{OTF}}{\boldsymbol{w}(V)-q_{OTF}}\right)^\delta
\end{equation}

to be a scalar between 0 and 1, which represents the amount of weight voting on a \PROP in addition to the minimum required by OTF. This will be multiplied with the rewards allocated for EF to calculate the final eligible amount. Here, $\delta \in \mathbb{N}$ is a parameter controlling the sensitivity of EF rewards to voting weight. For example, setting $\delta \geq 2$ makes the protocol less tolerant to absent weight.

\subsection{Reward Allocation and Eligibility}
\label{sec:reward-allocation-eligibility}

Let an era be defined as a consecutive set of ticks, and $I\subset\mathbb{N}$ be the set of feasible ticks in that era (see \ref{sec:round-feasibility}). In order for a round to be allocated any reward, it is not enough for it to be feasible. The leader must also be one of the assigned validators:

\begin{equation}
\bar{I}=\{i\in I \mid \mathcal{L}(i) \in V_i\}
\end{equation}

We introduce the following function to calculate the total supply of CLX

\begin{equation}
Q(i) = Q_0 (1+\sigma)^{i/\text{ticks\_per\_year}}
\end{equation}

where $Q_0$ is the initial supply, $\sigma$ is the yearly seiginorage rate and $\text{ticks\_per\_year} = 365\times 24\times 60 \times 60 \times 1000 = 31,\!536,\!000,\!000$.


We assume that there is an optimal round exponent, $n^\ast$ , which all the validators should operate at, given nominal conditions. We introduce the function, $r:\bar{I}\to \mathbb{Z}_{\geq 0}$, which maps a tick to the corresponding round reward:

\begin{equation}
  r(i) = \pow(2, {\min(n_{\mathcal{L}(i)}(i) - n^\ast, 0)}) \times (Q(i + 2^{n^\ast}) - Q(i))
\end{equation}

This expression demands an explanation: While we allow for round exponents lower than $n^\ast$---i.e. rounds faster than optimum---, we also throttle the round reward accordingly, to eliminate the incentives to underestimate round exponents\footnote{Specifically, the scenario where validators propose empty blocks with very small round exponents in order to receive more seigniorage. This is a viable scenario, because smaller blocks can be propagated faster.}. For round exponents smaller than $n^\ast$, the reward received per unit time is kept roughly constant owing to the factor on the left. For round exponents larget than $n^\ast$, however, the reward received per unit time decreases, because this time, the reward per round is kept constant. This way, validators are disincentivized from participating in rounds slowlier than the optimum speed.

Additionally, we define a parameter $\epsilon$ that dictates the ratio of OTF and EF rewards, i.e.~$r(i)\epsilon$ is allocated for the OTF and $r(i)(1-\epsilon)$ is allocated for the EF of the \PROP sent on $i$.

Once a \PROP is sent and enough time has passed, the history of messages can be examined to detect whether the round was indeed finalized on time, according to the conditions given above.

If the round is not finalized on time, validators do not receive any rewards. In other words, $r(i)$ tokens are burned.

If the round \emph{is} finalized on time, \emph{only the assigned validators} share the allocated OTF reward pro rata, regardless of whether they have sent messages or not. However, EF rewards go to all validators. Each validator $v$ in $V_i$ receives $r(i)\epsilon \,\boldsymbol{w}(v)/\boldsymbol{w}(V_i)$ for OTF and each validator $v\in V$ receives $r(i)(1-\epsilon)f_{EF}\boldsymbol{w}(v)/\boldsymbol{w}(V)$ for EF. To summarize, each $v\in V$ receives

\begin{equation}
  r_{i,v} = \begin{cases} r(i)\boldsymbol{w}(v)[\epsilon/\boldsymbol{w}(V_i) + (1-\epsilon)f_{EF}/\boldsymbol{w}(V)] &\text{if}\quad v\in V_i\\
    r(i)\boldsymbol{w}(v)(1-\epsilon)f_{EF}/\boldsymbol{w}(V) & \text{otherwise}
  \end{cases}
\end{equation}

for round $i$ if OTF is successful. Note that the EF reward is scaled with $f_{EF}$, which is proportional to the weight that votes in addition to $q_{OTF}$. This means that $r(i)(1-\epsilon)(1-f_{EF})$ tokens are burned for each round, if the eventual weight voting on a \PROP is smaller than 100\% of the total weight.

% To be decided: We can think of a less harsh scheme, where the reward decays exponentially with each elapsed round in which the round was not finalized on time. This could be more suitable than burning all of the reward, given the possible failures that can happen at the network layer, especially in the beginning.

% \subsection{Disincentives for Underestimating Round Exponents}
% \label{sec:disincentivizing-validators-from-underestimating-round-exponents}

% Truthful announcement of round exponents is essential for liveness. However, certain strategies exist where individual validators may earn more rewards by announcing a much lower round exponent than the majority of the validators, e.g.~0. This would function like a catch-all, where the validator would be assigned to every tick and rewarded for feasible rounds with successful OTF, but not punished for being assigned to infeasible rounds. This strategy would simply increase the odds of receiving rewards.

% We do not want underestimating round exponents to be a dominant strategy, so we need to introduce a rule that punishes it:

% \begin{quote}
% If a validator assigns themself to $\eta$ or more infeasible ticks consecutively, they do not receive any reward from their next feasible round.
% \end{quote}

% The allocated reward is simply burned. Here, $\eta$ is a protocol parameter.

% Let us assume that each validator $v$ keeps their round exponent constant, at $n_v$. Then the minimum round exponent that does not result in any assignment to an infeasible round is calculated as

% \begin{equation}
%   n_{\min} = \min\{n \mid  \boldsymbol{w}(\{v\mid n_v \geq n\}) \geq q_{OTF} \}.
% \end{equation}

% With the above rule, we increase the underestimating strategy's minimum viable round exponent from 0 to

% \begin{equation}
%   n_\text{underestimate} = n_{\min}-\lfloor \log_2\eta\rfloor.
% \end{equation}

% In other words, a validator following the strategy cannot linger more than $\lfloor \log_2\eta\rfloor$ below what most other validators have announced. For example, if $n_{\min}=16$ and $\eta = 5$, setting a round exponent smaller than 14 would result in not getting any reward from feasible rounds.

% Moreover, round exponents are not kept constant, and can be set to a new value in any message. Therefore $\eta$ should be set to a value that gives validators enough time to react to a sudden increment or decrement of the overall round exponent, e.g.~at least 3.

