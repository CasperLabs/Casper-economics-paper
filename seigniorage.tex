\section{Seigniorage}

% Outline which type of behavior we want to incentivize:

% It is ideal to have the validators converge on the same round exponent, because then the participated weight would be maximized for each round. For that reason, reward allocated per round is a function of the total weight assigned to the corresponding tick.


In Highway, validators are rewarded for proposing and finalizing blocks. New tokens are minted at the end of each era through seigniorage, and distributed to validators according to their performance in that era. We do not have constant block rewards as in Proof of Work blockchains like Bitcoin and Ethereum---instead, a certain amount of reward is allocated for each protocol round\footnote{We don't set the round reward to a constant value, because the CLX supply is set to be compounded continuously. Effectively, the round reward will appear to be constant in the short term, but will indeed grow at a very small but an ever-increasing rate, in order to keep the \emph{rate} of supply growth constant. See Section~\ref{sec:reward-allocation-eligibility} for more details.}, and paid out to validators while looking at multiple factors, such as finality and participated weight. We immediately make the following distinction to avoid future confusion:

\begin{description}
\item[Weight:] a validator's bonded stake used in consensus.
\item[Assigned weight:] the total stake of validators that are scheduled to participate in a round.
\item[Participated weight:] the total stake of validators that actually end up participating, which requires sending messages to finalize a round before it ends.
\end{description}

In general, we will be looking at two criteria to determine the validators' eligibility to receive rewards from a participated round:

\begin{description}
\item[On-time finalization (OTF):] Validators should finalize rounds on time, by sending required messages before their respective rounds end. We set OTF to require only a small but sufficient participating weight, for a simple reason: the probability of receiving a message on time decreases as the duration required for that approaches network propagation delay, so there is a trade-off between round lengths and assigned weight. We favor faster rounds over higher short-term safety guarantees, and argue that the latter can be achieved once the rounds end.
\item[Eventual finality (EF):] Complementary to the lower safety guarantees of OTF, we want all validators to vote in a round once a long enough time passes. This is possible, because validators that are not assigned to a round can still vote for it by participating on one of its descendants. The higher the weight voting in a round, the better.
\end{description}

We emulate the evolution of finality in Proof of Work blockchains by having validators to finalize a round with a relatively low but sufficiently high guarantee in the short run, and incentivizing them to provide the highest guarantee in the long run. This mirrors how a block becomes safer in Proof of Work as more blocks pile up on it.

For a given round, complementary portions of the round reward is allocated for OTF and EF respectively. Eligibility for OTF rewards follows an all-or-nothing approach: it is burned if the round is not finalized on time. EF eligibility, on the other hand, exists on a sliding scale: the more weight votes in a round, the more of the allocated portion is rewarded. This incentivizes validators to increase the weight voting for blocks in the long run.


% \subsection{Finality Criteria}
% \label{sec:finality-criteria}

% \subsubsection*{On-Time Finalization}
% \label{sec:on-time-finalization}

% OTF is concerned with the finality that is achieved in the short run, with in-round messages. For the sake of detecting this short-term finality, we restrict ourselves to \emph{summits that are achievable only by in-round messages}.

% A summit is defined as $\mathcal{S}=((C_j)_{j\in\mathbb{N}}, \sigma,p,p',q)$ where the respective properties $p$ and $p'$ are determined by the fork choice rule. We are interested in summits achievable only by valid in-round messages, so we introduce the property

% \begin{equation}
%   p_i = \{\mu \mid i \leq T(\mu)< i+2^{n_{S(\mu) }(i)}\}
% \end{equation}

% to be true for valid messages sent in round $i$. Then we extend $p'$ to obtain

% \begin{equation}
%   p'_{i}(\mu) = p'(\mu)\quad\text{and}\quad p_{i}(\mu)
% \end{equation}

% and introduce for a round $i$ the maximal level-1 summit achieved only by in-round messages, $\mathcal{S}_i=((C_j)_{j\in\mathbb{N}}, \sigma,p,p'_{i},q)$. We use \emph{participated weight} as a synonym for $q$, that is, the quorum size of the maximal level-1 summit.

% With this extended definition, we are ready to define on-time finality: A \PROP sent on $i$ is said to be \emph{finalized on time} only if $q \geq q_{OTF}$ once the rounds of all participants end.

% We also note that participated weight must be less than or equal to assigned weight, that is, $q \leq \boldsymbol{w}(V_i)$, as a consequence of the round schedule.

% \subsubsection*{Eventual Finality}
% \label{sec:eventual-finality}

% EF is concerned with the finality that is achieved in the long run, and is not restricted to in-round messages. This way, the weight on a \PROP can increase up to 100\% of the total weight. Unlike OTF, which fails if a base level of weight is not observed by the end of the round, EF is not binary. It exists on a sliding scale: the higher the weight, the better.

% The goal is to have all validators voting on a \PROP by the end of the era. Let $\mathcal{S}$ be the maximal level-1 summit on a \PROP, according to all messages sent until the end of the era. If OTF was successful, then we already have $q\geq q_{OTF}$. We define

% \begin{equation}
% f_{EF} = \frac{q - q_{OTF}}{\boldsymbol{w}(V)-q_{OTF}}
% \end{equation}

% to be a scalar between 0 and 1, which represents the amount of weight voting on a \PROP in addition to the minimum required by OTF. This will be multiplied with the rewards allocated for EF to calculate the final eligible amount.

\subsection{Reward Allocation and Eligibility}
\label{sec:reward-allocation-eligibility}

Let an era be defined as a consecutive set of ticks, and $I\subset\mathbb{N}$ be the set of feasible ticks in that era (see \ref{sec:round-feasibility}). In order for a round to be allocated any reward, it is not enough for it to be feasible. The leader must also be one of the assigned validators:

\begin{equation}
\bar{I}=\{i\in I \mid \mathcal{L}(i) \in V_i\}
\end{equation}

We introduce the function

\begin{equation}
Q(i) = Q_0 (1+\sigma)^{i/\text{ticks\_per\_year}}
\end{equation}

to model how the CLX supply would evolve under \emph{ideal conditions}\footnote{The function $Q$ does not dictate the exact size of the supply, but rather, used to set an upper limit to how much it can be at a given tick.}. Here, $Q_0$ is the initial supply, $\sigma$ is the yearly seiginorage rate and $\text{ticks\_per\_year} = 365\times 24\times 60 \times 60 \times 1000 = 31,\!536,\!000,\!000$. However, CLX supply will most likely not grow ideally, due to slashings and rounds which are not rewarded. Our goal is to make the \emph{real} rate of seigniorage stay constant, so we need to base round rewards on the current supply, rather than the ideal.

Instead of forcing the protocol to keep track of changes to supply on a block-by-block basis, we take the final supply of the previous era as a benchmark, to calculate how much the round reward should be for a given era, throughout which it stays constant. This greatly reduces the complexity of what needs to be implemented without sacrificing anything that is crucial for seigniorage to work. We also assume that there is an optimal round exponent, $n^\ast$ , which all the validators should operate at, in ideal conditions. This allows us to derive the seigniorage rate for an optimal round

\begin{equation}
  \sigma^\ast = \pow(1 + \sigma, 2^{n^\ast}/\text{ticks\_per\_year}) - 1
\end{equation}

Then, we can calculate the \emph{base round reward} for a given era as

\begin{equation}
  r^\ast = \sigma^\ast Q_\text{prev}
\end{equation}

where $Q_\text{prev}$ is the final supply of the previous era.

Finally, we introduce the function, $r:\bar{I}\to \mathbb{Z}_{\geq 0}$, which maps a tick to the corresponding round reward:

\begin{equation}
  % r(i) = \pow(2, {\min(n_{\mathcal{L}(i)}(i) - n^\ast, 0)}) \times (Q(i + 2^{n^\ast}) - Q(i))
  r(i) = r^\ast\pow(2, {\min(n_{\mathcal{L}(i)}(i) - n^\ast, 0)})
\end{equation}

This expression demands an explanation: While we allow for round exponents lower than $n^\ast$---i.e. rounds faster than optimum---, we also throttle the round reward accordingly, to eliminate the incentives to underestimate round exponents\footnote{Specifically, the scenario where validators propose empty blocks with very small round exponents in order to receive more seigniorage. This is a viable strategy, because smaller blocks can be propagated faster.}. For round exponents smaller than $n^\ast$, the reward received per unit time is kept constant by halving the base round reward. For round exponents larger than $n^\ast$, however, the reward received per unit time decreases, because this time, the reward per round is kept constant. This way, validators are disincentivized from participating in rounds more slowly than the optimum speed.

Additionally, we define a parameter $\epsilon$ that dictates the ratio of OTF and EF rewards, i.e.~$r(i)\epsilon$ is allocated for the OTF and $r(i)(1-\epsilon)$ is allocated for the EF of the \PROP sent on $i$.

Once a \PROP is sent and enough time has passed, the history of messages can be examined to detect whether the round was indeed finalized on time, according to the conditions given above.

If the round is not finalized on time, validators do not receive any rewards. In other words, $r(i)$ tokens are burned.

If the round \emph{is} finalized on time, \emph{only the assigned validators} share the allocated OTF reward pro rata, regardless of whether they have sent messages or not. However, EF rewards go to all validators. Each validator $v$ in $V_i$ receives $r(i)\epsilon \,\boldsymbol{w}(v)/\boldsymbol{w}(V_i)$ for OTF and each validator $v\in V$ receives $r(i)(1-\epsilon)f_{EF}\boldsymbol{w}(v)/\boldsymbol{w}(V)$ for EF. To summarize, each $v\in V$ receives

\begin{equation}
  r_{i,v} = \begin{cases} r(i)\boldsymbol{w}(v)[\epsilon/\boldsymbol{w}(V_i) + (1-\epsilon)f_{EF}/\boldsymbol{w}(V)] &\text{if}\quad v\in V_i\\
    r(i)\boldsymbol{w}(v)(1-\epsilon)f_{EF}/\boldsymbol{w}(V) & \text{otherwise}
  \end{cases}
\end{equation}

for round $i$ if OTF is successful. Note that the EF reward is scaled with $f_{EF}$, which is proportional to the weight that votes in addition to $q_{OTF}$. This means that $r(i)(1-\epsilon)(1-f_{EF})$ tokens are burned for each round, if the eventual weight voting on a \PROP is smaller than 100\% of the total weight.

% To be decided: We can think of a less harsh scheme, where the reward decays exponentially with each elapsed round in which the round was not finalized on time. This could be more suitable than burning all of the reward, given the possible failures that can happen at the network layer, especially in the beginning.

% \subsection{Disincentives for Underestimating Round Exponents}
% \label{sec:disincentivizing-validators-from-underestimating-round-exponents}

% Truthful announcement of round exponents is essential for liveness. However, certain strategies exist where individual validators may earn more rewards by announcing a much lower round exponent than the majority of the validators, e.g.~0. This would function like a catch-all, where the validator would be assigned to every tick and rewarded for feasible rounds with successful OTF, but not punished for being assigned to infeasible rounds. This strategy would simply increase the odds of receiving rewards.

% We do not want underestimating round exponents to be a dominant strategy, so we need to introduce a rule that punishes it:

% \begin{quote}
% If a validator assigns themself to $\eta$ or more infeasible ticks consecutively, they do not receive any reward from their next feasible round.
% \end{quote}

% The allocated reward is simply burned. Here, $\eta$ is a protocol parameter.

% Let us assume that each validator $v$ keeps their round exponent constant, at $n_v$. Then the minimum round exponent that does not result in any assignment to an infeasible round is calculated as

% \begin{equation}
%   n_{\min} = \min\{n \mid  \boldsymbol{w}(\{v\mid n_v \geq n\}) \geq q_{OTF} \}.
% \end{equation}

% With the above rule, we increase the underestimating strategy's minimum viable round exponent from 0 to

% \begin{equation}
%   n_\text{underestimate} = n_{\min}-\lfloor \log_2\eta\rfloor.
% \end{equation}

% In other words, a validator following the strategy cannot linger more than $\lfloor \log_2\eta\rfloor$ below what most other validators have announced. For example, if $n_{\min}=16$ and $\eta = 5$, setting a round exponent smaller than 14 would result in not getting any reward from feasible rounds.

% Moreover, round exponents are not kept constant, and can be set to a new value in any message. Therefore $\eta$ should be set to a value that gives validators enough time to react to a sudden increment or decrement of the overall round exponent, e.g.~at least 3.

